学习Go GC 20问做的一些笔记

学习参考：Github 开源项目 《Go-Questions》

### GC的认识

1、什么是GC,有什么用？

GC,全称GarbageCollection,即垃圾回收机制，是一种自动内存管理的机制

当程序向操作系统申请的内存不在需要时***(什么时候代表申请的内存不在需要)***，垃圾回收主动将其回收并供其他程序申请内存，或者将其归还给操作系统，这种针对内存级别的资源自动回收，即为垃圾回收，负责垃圾回收的程序组件，即为***垃圾回收器***

一方面，程序员收益于GC，无需操心，也不需要对内存进行手动的申请和释放，GC在程序运行时自动释放残留的内存，另一方面，GC对程序员几乎不可见，仅程序需要进行特殊优化时运行开销进行把控的时候才得以现身

***重点来了***

通常，垃圾回收器的执行过程被划分为两个半独立的组件：

~赋值器(Mutator):这一名称本质上是指代用户态的代码，因为对垃圾回收而言，用户态的代码仅仅只是在修改对象之间的引用关系，也就是在对象图之间的引用关系，也就是在对象图(对象之间引用关系的一个有向图)【***多读几遍***】

~回收器(Collector)负责执行垃圾回收的代码

2、根对象到底指什么？【***没怎么看明白***】

根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程中最先检查的对象，包括

1、全局变量：程序在编译器就能够确定的那些存在程序整个生命周期的变量

2、执行栈：每一个goroutine都包含自己的执行栈，这些执行栈上包含栈上的变量和指向分配的堆内存区块的指针

3、寄存器：寄存器的值可能表示一个指针，参与计算的这些指针指向某些赋值器分配的堆内存区块

3、常见的GC实现方式有哪些？Go语言的Gc使用的是什么？

所有的GC算法存在形式可以归结为追踪和引用计数这两种形式的混合运用

目前比较常见的 GC 实现方式包括：

- 追踪式，分为多种不同类型，例如：
- 标记清扫：从根对象出发，将确定存活的对象进行标记，并清扫可以回收的对象。
- 标记整理：为了解决内存碎片问题而提出，在标记过程中，将对象尽可能整理到一块连续的内存上。
- 增量式：将标记与清扫的过程分批执行，每次执行很小的部分，从而增量的推进垃圾回收，达到近似实时、几乎无停顿的目的。
- 增量整理：在增量式的基础上，增加对对象的整理过程。
- 分代式：将对象根据存活时间的长短进行分类，存活时间小于某个值的为年轻代，存活时间大于某个值的为老年代，永远不会参与回收的对象为永久代。并根据分代假设（如果一个对象存活时间不长则倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间）对对象进行回收。
- 引用计数：根据对象自身的引用计数来回收，当引用计数归零时立即回收。

关于各类方法的详细介绍及其实现不在本文中详细讨论。对于 Go 而言，Go 的 GC 目前使用的是无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法。原因在于：

1. 对象整理的优势是解决内存碎片问题以及“允许”使用顺序内存分配器。但 Go 运行时的分配算法基于 tcmalloc，基本上没有碎片问题。并且顺序内存分配器在多线程的场景下并不适用。Go 使用的是基于 tcmalloc 的现代内存分配算法，对对象进行整理不会带来实质性的性能提升。
2. 分代 GC 依赖分代假设，即 GC 将主要的回收目标放在新创建的对象上（存活时间短，更倾向于被回收），而非频繁检查所有对象。但 Go 的编译器会通过逃逸分析将大部分新生对象存储在栈上（栈直接被回收），只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。也就是说，分代 GC 回收的那些存活时间短的对象在 Go 中是直接被分配到栈上，当 goroutine 死亡后栈也会被直接回收，不需要 GC 的参与，进而分代假设并没有带来直接优势。并且 Go 的垃圾回收器与用户代码并发执行，使得 STW 的时间与对象的代际、对象的 size 没有关系。Go 团队更关注于如何更好地让 GC 与用户代码并发执行（使用适当的 CPU 来执行垃圾回收），而非减少停顿时间这一单一目标上。



